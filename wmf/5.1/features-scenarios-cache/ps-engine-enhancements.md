---
title: "Улучшения подсистемы PowerShell"
author: jasonsh
translationtype: Human Translation
ms.sourcegitcommit: 6813902aec214aee9ede27ff79dd291364e9f443
ms.openlocfilehash: f864850128f118704d7545b09110835ab1d51b8e

---

# Улучшения подсистемы PowerShell #

В PowerShell 5.1 были реализованы перечисленные ниже улучшения основной подсистемы PowerShell.


## Производительность ##

Производительность улучшена в некоторых важных аспектах:

1. Запуск
2. Передача данных по конвейеру в такие командлеты, как ForEach-Object и Where-Object, выполняется примерно на 50 % быстрее. 

Примеры некоторых улучшений (результаты могут различаться в зависимости от оборудования): 

| Сценарий | Время в версии 5.0 (мс) | Время в версии 5.1 (мс) |
| -------- | :---------------: | :---------------: |
| `powershell -command "echo 1"` | 900 | 250 |
| Самый первый запуск PowerShell: `powershell -command "Unknown-Command"` | 30 000 | 13 000 |
| Построение кэша анализа команд: `powershell -command "Unknown-Command"` | 7000 | 520 |
| <code>1..1000000 &#124; % { }</code> | 1400 | 750 |
  
Одно из изменений, связанных с запуском, может повлиять на некоторые (неподдерживаемые) сценарии. PowerShell больше не считывает файлы `$pshome\*.ps1xml` — эти файлы были преобразованы в C# во избежание накладных расходов, связанных с обработкой XML-файлов. Эти файлы по-прежнему существуют для поддержки параллельно установленной версии 2, поэтому изменение их содержимого сказывается только на версии 2, но не на версии 5. Обратите внимание на то, что изменение содержимого этих файлов никогда не поддерживалось.

Еще одним явным изменением является то, как PowerShell кэширует экспортируемые команды и другую информацию для модулей, установленных в системе. Ранее этот кэш хранился в каталоге `$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`. В WMF 5.1 этот кэш является отдельным файлом `$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`.
Подробные сведения см. в разделе, посвященном файлу [analysis_cache.md]().

Начиная с версии 5.1 доступны различные выпуски среды PowerShell, что означает различные наборы возможностей и совместимость с разными платформами.



## Устранение ошибок ##

Исправлены перечисленные ниже важные ошибки.

### При автоматическом обнаружении модулей полностью учитывается `$env:PSModulePath` ###

Автоматическое обнаружение модулей (их автоматическая загрузка без явного вызова Import-Module при вызове команды) появилось в WMF3. В этой версии среда PowerShell проверяла команды в `$PSHome\Modules` перед использованием `$env:PSModulePath`.

В WMF 5.1 это поведение изменилось: `$env:PSModulePath` учитывается полностью. Это позволяет автоматически загружать созданные пользователями модули, в которых определяются предоставляемые PowerShell команды (например, `Get-ChildItem`), и правильно переопределять встроенные команды.

### При перенаправлении файлов больше не задается жестко `-Encoding Unicode` ###

Во всех предыдущих версиях PowerShell было невозможно контролировать кодировку файлов, используемую оператором перенаправления файлов, например `get-childitem > out.txt`, так как среда PowerShell добавляла параметр `-Encoding Unicode`.

Начиная с версии WMF 5.1 можно изменять кодировку файлов при перенаправлении, задавая `$PSDefaultParameterValues`, например:

```
$PSDefaultParameterValues["Out-File:Encoding"] = "Ascii"
```

### Исправлена регрессия при доступе к членам `System.Reflection.TypeInfo` ###

Появившаяся в WMF 5 регрессия нарушала доступ к членам `System.Reflection.RuntimeType`, например `[int].ImplementedInterfaces`.
Эта ошибка исправлена в WMF 5.1.


### Исправлены некоторые проблемы с объектами COM ###

В WMF 5 появился новый модуль привязки COM для вызова методов применительно к COM-объектам и доступа к свойствам COM-объектов.
Этот новый модуль значительно повысил производительность, но в нем был ряд ошибок, которые исправлены в WMF 5.1.

#### Преобразование аргументов не всегда выполнялось правильно ####

Рассмотрим следующий пример:

```
$obj = new-object -com wscript.shell
$obj.SendKeys([char]173)
```

Метод SendKeys требует строку, но среда PowerShell не преобразовала char в string, отложив преобразование до вызова метода IDispatch::Invoke, который использует VariantChangeType для выполнения преобразования. В этом примере это приводит к отправке ключей "1", "7" и "3" вместо требуемого ключа Volume.Mute.

#### Перечисляемые COM-объекты не всегда обрабатывались правильно ####

Среда PowerShell, как правило, перечисляет большинство перечисляемых объектов, но регрессия, появившаяся в WMF 5, препятствовала перечислению COM-объектов, реализующих интерфейс IEnumerable.  Например:

```
function Get-COMDictionary
{
    $d = New-Object -ComObject Scripting.Dictionary
    $d.Add('a', 2)
    $d.Add('b', 2)
    return $d
}

$x = Get-COMDictionary
```

В приведенном выше примере WMF 5 неправильно записывает Scripting.Dictionary в конвейер вместо перечисления пар "ключ-значение".


### `[ordered]` не разрешалось использовать в классах ###

В WMF 5 появились классы, в которых проверялось использование литералов типов.  `[ordered]` выглядит как литерал типа, но в действительности не является типом .Net.  В WMF 5 неправильно выдавалась ошибка для `[ordered]` внутри класса:

```
class CThing
{
    [object] foo($i)
    {
        [ordered]@{ Thing = $i }
    }
}
```


### Вызов разделов справки при наличии нескольких версий не работал ###

До версии WMF 5.1 при наличии нескольких установленных версий модуля с общим разделом справки, например "about_PSReadline", команда `help about_PSReadline` возвращала несколько разделов без возможности просмотреть саму справку.

В WMF 5.1 эта проблема устранена: теперь возвращается последняя версия раздела.

Командлет Get-Help не позволяет указать версию, по которой требуется справка. В качестве обходного решения можно перейти к каталогу модулей и открыть справку напрямую, например с помощью любимого редактора. 



<!--HONumber=Jul16_HO2-->


